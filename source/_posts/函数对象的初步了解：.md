---
title: 函数对象
---

# 函数对象的初步了解：

<!-- more -->

## 第一：

list 的sort 函数直接调用， 可以把list 从小到大进行一个排序，

如果我们现在的需求是将list 从大到小进行一个排序

看源码我们知道 sort 函数的参数是一个Compare comp，是一个对象。

```
std::list <T,Allocator>::sort

void sort();

template <class Compare>

void sort(Compare comp);
```

**Compare  本质是把两个数进行了比较，是一个类型，**

**comp 是一个对象，**

![image-20230730154149527](C:\Users\15183\AppData\Roaming\Typora\typora-user-images\image-20230730154149527.png)

而且在set 中也会从小到大的顺序进行排序

看set 的源码，我们知道了class Compare 的本质。

![image-20230730154320927](C:\Users\15183\AppData\Roaming\Typora\typora-user-images\image-20230730154320927.png)

```
class Compare = std::less<key>
```

然而std::less<key> 是一个struct 是一个类，

- [ ] [**这个类重载了函数调用运算符（），那么重载了函数调用运算符的类 与小括号进行结合 ，可以体现函数的特性，称为函数对象**]()！！！！！

![image-20230730154518867](C:\Users\15183\AppData\Roaming\Typora\typora-user-images\image-20230730154518867.png)

那么就表明

sort 底层就是可能调用的是std::less

sort函数的参数

void sort （Compare comp）Compare是一个类型，但是comp是一个对象，

并且没有添加引用，

list.sort(**std::less<int>(**));

**std::less<int>(),是一个函数对象**

如果我们要满足刚开始的需求

我么只需要 list.sort（std::greater<int>()）即可。

自己实现Compare：

```
struct CompareList
{
	operator()(const int &lhs,const int &rhs) const
	{
	return lhs <rhs;
	}
}
```



