---
title: Struct
---
# 结构体

 结构体(struct)是由一系列具有相同类型或不同类型的数据构成的数据集合，也叫结构。
<!-- more -->
结构体和其他类型基础数据类型一样，例如int类型，char类型只不过结构体可以做成你想要的数据类型。以方便日后的使用。

在实际项目中，结构体是大量存在的。研发人员常使用结构体来封装一些属性来组成新的类型。由于C语言无法操作数据库，所以在项目中通过对结构体内部变量的操作将大量的数据存储在内存中，以完成对数据的存储和操作。在实际问题中有时候我们需要几种数据类型一起来修饰某个变量。例如一个学生的信息就需要学号（字符串），姓名（字符串），年龄（整形）等等。这些数据类型都不同但是他们又是表示一个整体，要存在联系，那么我们就需要一个新的数据类型。——结构体，它就将不同类型的数据存放在一起，作为一个整体进行处理。结构体在函数中的作用不是简便，其最主要的作用就是封装。封装的好处就是可以再次利用。让使用者不必关心这个是什么，只要根据定义使用就可以了。结构体的大小不是结构体元素单纯相加就行的，因为我们现在主流的计算机使用的都是32Bit字长的CPU，对这类型的CPU取4个字节的数要比取一个字节要高效，也更方便。所以在结构体中每个成员的首地址都是4的整数倍的话，取数据元素时就会相对更高效，这就是内存对齐的由来。每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。程序员可以通过预编译命令#pragmapack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。

**规则**

1、数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragmapack指定的数值和这个数据成员自身长度中，比较小的那个进行。

2、结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragmapack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。

3、结合1、2可推断：当#pragmapack的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。

在C语言中，可以定义结构体类型，将多个相关的变量包装成为一个整体使用。在结构体中的变量，可以是相同、部分相同，或完全不同的数据类型。在C语言中，结构体不能包含函数。在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。C语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展，C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而不是private。

**结构体的声明：**

```cpp
struct Stu
{
	//结构体成员
	char name[20];
	int age;
	char sex[10];
	char tele[12];
};
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

这个声明描述了一个由三个字符数组和一个int变量组成的结构体。但是注意，它并没有创建一个实际的数据对象，而是描述了一个组成这类对象的元素。因此，我们有时候也将结构体声明叫做模板，因为它勾勒出数据该如何存储，并没有实例化数据对象。

下面介绍一下上面的结构体声明：

1、首先使用关键字struct，它表示接下来是一个结构体。

2、后面是一个可选的标志（book），它是用来引用该结构体的快速标记。因此我们以后就可以这样创建数据对象

struct book library；//把library设为一个可以使用book结构体的结构体变量，则library这个变量就包含了其book结构体中的所有元素

3、接下来就是一个花括号，括起了结构体成员列表，及每个成员变量，使用的都是其自己的声明方式来描述，用分号来结束描述；

例如：char name[20];字符数组就是这样声明的，用分号结束；

注意：其中每个成员可以使用任何一种C数据结构甚至是其他的结构体，也是可以的；

4、在结束花括号后的分号表示结构体设计定义的结束。

关于其struct声明的位置，也就是这段代码要放到哪里。同样这也是具有作用域的。

这种声明如果放在任何函数的外面，那么则可选标记可以在本文件中，该声明的后面的所有函数都可以使用。

如果这种声明在某个函数的内部，则它的标记只能在内部使用，并且在其声明之后；

```cpp
//声明一个结构体，值得注意的是如果main函数在结构体前面会报错，这个可以自己试一下！1
struct Stu
{
	//结构体成员
	char name[20];
	int age;
	char sex[10];
	char tele[12];
};//分号不能少这相当于一条语句
int main() {

	struct Stu s = { "zhangsan", 20, "nan", "18338064521" };//对结构体初始化
	printf("%s %d %s %s\n", s.name, s.age,s.sex, s.tele);
	return 0;
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

C语言结构体定义的三种方式

1、最标准的方式:

```cpp
#include <stdio.h>
struct student //结构体类型的说明与定义分开。声明
{
int age;  /*年龄*/
float score; /*分数*/
char sex;   /*性别*/
};
int main ()
{
struct student a={ 20,79,'f'}; //定义
printf("年龄：%d 分数：%.2f 性别：%c\n", a.age, a.score, a.sex );
return 0;
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)



2、不环保的方式

```cpp
#include <stdio.h>
struct student /*声明时直接定义*/
{
int age;  /*年龄*/
float score;  /*分数*/
char sex;   /*性别*/
/*这种方式不环保，只能用一次*/
} a={21,80,'n'};
int main ()
{
printf("年龄：%d 分数：%.2f 性别：%c\n", a.age, a.score, a.sex );
return 0;
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)



3、最奈何人的方式

```cpp
#include <stdio.h>
struct   //直接定义结构体变量，没有结构体类型名。这种方式最烂
{
int age;
float score;
char sex;
} t={21,79,'f'};
int main ()
{
printf("年龄：%d 分数：%f 性别：%c\n", t.age, t.score, t.sex);
return 0;
}
return 0;
}
}
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)



**定义结构体变量**

之前我们结构体类型的定义（结构体的声明）只是告诉编译器该如何表示数据，但是它没有让计算机为其分配空间。

我们要使用结构体，那么就需要创建变量，也就是结构体变量；

创建一个结构体变量；

```cs
struct book library；
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

看到这条指令，编译器才会创建一个结构体变量library，此时编译器才会按照book模板为该变量分配内存空间，并且这里存储空间都是以这个变量结合在一起的。

这也是后面访问结构体变量成员的时候，我们就要用到结构体变量名来访问。

struct book的作用：

在结构体声明中，struct book所起到的作用就像int，，，，等基础数据类型名作用一样。

```cs
struct book s1，s2，*ss；
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

定义两个struct book结构体类型的结构体变量，还定义了一个指向该结构体的指针，其ss指针可以指向s1，s2，或者任何其他的book结构体变量。

其实；

```cs
struct book library；
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

等效于；

```cs
struct book{ char … …. ….. }librar；
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

这两种是等效的，只是第一种可以减少代码的编写量；

其一；

```cs
struct{ char title[MAXTITL]; char author[MAXAUTL];float value；}library;
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

//注意这里不再是定义声明结构体类型，而是直接创建结构体变量了，这个编译器会分配内存的；

//这样的确可以省略标识符也就是结构体名，但是只能使用一次；因为这是；声明结构体的过程和定义结构体变量的过程和在了一起；并且个成员变量没有初始化的；

//如果你想多次使用一个结构体模块，这样子是行不通的；



其二；

用typedef定义新类型名来代替已有类型名，即给已有类型重新命名；

一般格式为；typedef 已有类型 新类型名；

```cs
typedef int Elem; typedef struct{ int date; ..... .....}STUDENT;STUDENT stu1,stu2;
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

![img](https://img-blog.csdnimg.cn/11bfe77039374543b18a69240005e904.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑

**总结一下关于结构体变量的定义；**

1、先定义结构体类型后再定义结构体变量；

格式为；struct 结构体名 变量名列表；

```cs
struct book s1，s2，*ss；//注意这种之前要先定义结构体类型后再定义变量；
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

2、在定义结构体类型的同时定义结构体变量；

格式为；

```cs
struct 结构体名{成员列表；}变量名列表；//这里结构体名是可以省的，但尽量别省；struct book{char title[MAXTITL];//一个字符串表示的titile 题目 ；char author[MAXAUTL];//一个字符串表示的author作者 ；float value;//一个浮点型表示的value价格；}s1，s2
```

![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

直接定义结构体类型变量，就是第二种中省略结构体名的情况；

这种方式不能指明结构体类型名而是直接定义结构体变量，并且在值定义一次结构体变量时适用，无结构体名的结构体类型是无法重复使用的。

也就是说，后面程序不能再定义此类型变量了，除非再写一次重复的struct。